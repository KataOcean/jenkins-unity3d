import os
from unittest import TestCase, mock

from src.gitlab_ci_generator import GitlabCiGenerator
from tests.utils import full_path_from_relative_path, captured_output


class TestGitlabCiGenerator(TestCase):
    class_path = 'src.gitlab_ci_generator.GitlabCiGenerator'

    def test_get_rendered_ci_template(self):
        ci_generator = GitlabCiGenerator()

        rendered_ci_template = ci_generator.get_rendered_ci_template()
        self.assertIsNotNone(rendered_ci_template)

    def test_get_ci_yaml_template(self):
        ci_generator = GitlabCiGenerator()

        ci_yaml_template = ci_generator.get_ci_yaml_template()
        self.assertIn("gitlab-ci.jinja2", ci_yaml_template)
        self.assertTrue(os.path.exists(ci_yaml_template))

    # TODO: improve test by mocking call to os.path.isfile(platform_dockerfile_path)
    def test_get_dockerfile_name_to_use(self):
        ci_generator = GitlabCiGenerator()

        dockerfile = ci_generator.get_dockerfile_name_to_use("android", {})
        self.assertEqual("unitysetup-android", dockerfile)

        dockerfile = ci_generator.get_dockerfile_name_to_use("windows", {})
        self.assertEqual("unitysetup", dockerfile)

        dockerfile = ci_generator.get_dockerfile_name_to_use("linux", {})
        self.assertEqual("unitysetup", dockerfile)

        dockerfile = ci_generator.get_dockerfile_name_to_use("mac", {})
        self.assertEqual("unitysetup", dockerfile)

        dockerfile = ci_generator.get_dockerfile_name_to_use("ios", {})
        self.assertEqual("unitysetup", dockerfile)

    def test_set_dockerfile_to_unity_versions(self):
        with self.subTest("empty unity_versions stays empty"):
            unity_versions = {}
            expected_unity_versions = {}
            self.do_test_set_dockerfile_to_unity_versions(expected_unity_versions, unity_versions)

        with self.subTest("windows component in unity_versions"):
            unity_versions = {
                "2019.1.3f1": {"platforms": {"windows": {"components": "unity"}}}
            }
            expected_unity_versions = {
                "2019.1.3f1": {"platforms": {"windows": {"components": "unity", "dockerfile_name": "unitysetup"}}}
            }
            self.do_test_set_dockerfile_to_unity_versions(expected_unity_versions, unity_versions)

        with self.subTest("android component in unity_versions uses different dockerfile"):
            unity_versions = {
                "2019.1.3f1": {"platforms": {"android": {
                    "components": "unity"
                }}}
            }
            expected_unity_versions = {
                "2019.1.3f1": {"platforms": {"android": {
                    "components": "unity", "dockerfile_name": "unitysetup-android"
                }}}
            }
            self.do_test_set_dockerfile_to_unity_versions(expected_unity_versions, unity_versions)

    def do_test_set_dockerfile_to_unity_versions(self, expected_unity_versions, unity_versions):
        ci_generator = GitlabCiGenerator()
        new_unity_versions = ci_generator.set_dockerfile_to_unity_versions(unity_versions)
        self.assertEqual(expected_unity_versions, new_unity_versions)

    def test_render_template(self):
        template = full_path_from_relative_path('data/test.jinja2')
        rendered_template = GitlabCiGenerator.render_template(template, {'context_data': 'test'})
        self.assertEqual(rendered_template, 'example with test')

    def test_print(self):
        ci_generator = GitlabCiGenerator()
        with mock.patch(f'{self.class_path}.get_rendered_ci_template') as mocked_get_rendered_ci_template:
            with mock.patch('builtins.print') as mocked_print:
                ci_generator.print()
                mocked_print.assert_called()
                self.assertEqual(mocked_print.call_count, 2)
                self.assertEqual(
                    mocked_print.call_args_list[0][0][0],
                    "# !!! Do not edit this file manually, see ci-generator folder !!!"
                )
                mocked_get_rendered_ci_template.assert_called_once()

    def test_snapshot(self):
        with self.subTest("unitysetup_2019"):
            ci_generator = GitlabCiGenerator()
            version_input = 'data/test_unitysetup_2019.yml'
            version_output = 'data/test_unitysetup_2019.out.yml'
            self.do_test_snapshot(ci_generator, version_input, version_output)

        with self.subTest("dockerfile_override"):
            ci_generator = GitlabCiGenerator()
            version_input = 'data/test_dockerfile_override.yml'
            version_output = 'data/test_dockerfile_override.out.yml'
            self.do_test_snapshot(ci_generator, version_input, version_output)

        with self.subTest("base_components_override"):
            ci_generator = GitlabCiGenerator()
            version_input = 'data/test_base_components_override.yml'
            version_output = 'data/test_base_components_override.out.yml'
            self.do_test_snapshot(ci_generator, version_input, version_output)

        with self.subTest("unitysetup_2017"):
            ci_generator = GitlabCiGenerator()
            version_input = 'data/test_unitysetup_2017.yml'
            version_output = 'data/test_unitysetup_2017.out.yml'
            self.do_test_snapshot(ci_generator, version_input, version_output)

        with self.subTest("unitysetup_2017_legacy"):
            ci_generator = GitlabCiGenerator()
            version_input = 'data/test_unitysetup_2017_legacy.yml'
            version_output = 'data/test_unitysetup_2017_legacy.out.yml'
            self.do_test_snapshot(ci_generator, version_input, version_output)

        with self.subTest("android_sdk_version"):
            ci_generator = GitlabCiGenerator()
            version_input = 'data/test_android_sdk_version.yml'
            version_output = 'data/test_android_sdk_version.out.yml'
            self.do_test_snapshot(ci_generator, version_input, version_output)

        with self.subTest("empty"):
            ci_generator = GitlabCiGenerator()
            version_input = 'data/test_empty.yml'
            version_output = 'data/test_empty.out.yml'
            self.do_test_snapshot(ci_generator, version_input, version_output)

    def do_test_snapshot(self, ci_generator, version_input, version_output):
        version_input_full_path = full_path_from_relative_path(version_input)
        version_output_full_path = full_path_from_relative_path(version_output)
        with captured_output() as (out, err):
            with mock.patch(f'{self.class_path}.get_unity_versions_path') as mocked_get_unity_versions_path:
                mocked_get_unity_versions_path.return_value = version_input_full_path
                ci_generator.print()
        output = out.getvalue().strip()
        # uncomment to generate snapshots
        # with open(version_output, 'w') as f:
        #     f.write(output)
        with open(version_output_full_path) as f:
            self.maxDiff = None
            self.assertEqual(output, f.read())
